---

############################################################
## Possibly different way to report the Checklist Status  ##
## Need to find a way to fail at the end if there are     ##
## any 'FAILED' checks.                                   ##
############################################################
# - name: check the kernel version
#   set_fact:
#     checklist: 
#       kernel_version: 
#         expected_value: 3
#         actual_value: "{{ ansible_kernel.split('.')[0] }}"
#         status: "{% if ansible_kernel.split('.')[0] | int < 3 -%}FAILED
#                  {%- else -%}PASSED
#                  {%- endif -%}"
#   tags: module

# - debug:
#     var: checklist
#   tags: module

# - fail:
#   when: checklist | json_query('[?..status == FAILED')
# - name: setting the fact 
#   set_fact:
#      failed_checks: ""

- name: setting the fact 
  set_fact:
     failed_checks: ""

- name: check the kernel version
  set_fact:  
    failed_checks: "{{ failed_checks | string }} Linux kernel version too low,"
  when: ansible_kernel.split('.')[0] | int < 3

- name: check swap size for virtuals (64GB RAM)
  set_fact:  
    failed_checks: "{{ failed_checks | string }} swap size should be more than 16384M for 64GB RAM or more,"
  when: 
  - ansible_swaptotal_mb | int < 16384
  - ansible_memtotal_mb | int > 65536

- name: check swap size for physicals (256GB RAM)
  set_fact:  
    failed_checks: "{{ failed_checks | string }} swap size should be more than 32768M for 256GB RAM or more,"
  when: 
  - ansible_swaptotal_mb < 32768
  - ansible_memtotal_mb | int > 262144

- name: populate service facts
  service_facts:  

- name: setting the fact 
  set_fact:  
    failed_checks: "{{ failed_checks | string }} sshd service is not running,"
  when: ansible_facts['services']['sshd.service']['state'] != "running"

##########################################################
## If this is always mounted a specific way for Charter ##
## we could check that mountpoint using Ansible Facts.  ##
## Otherwise, this is the only option for this.         ##
##########################################################
- name: check TMP directory
  shell: echo `df -kh /tmp | awk 'NR == 2 { print $4 }' | awk -F 'G' '{print $1}'`
  changed_when: False
  register: tmp_size

- name: setting the fact 
  set_fact:  
    failed_checks: "{{ failed_checks | string }} TMP directory size should be more than 4GB, {{ tmp_size.stdout | int | round }}"
  when: tmp_size.stdout | int | round < 4

##########################################################################
## There is no way to 'check' this without changing it.                 ##
## However, I don't see the harm here with this one making the change.  ##
##                                                                      ##
## If needed, I have left the original version in place, commented, and ##
## updated to be idempotent should Charter prefer to use it.            ##
##########################################################################
- name: ensure RW permission for all on /var/tmp
  file:
    path: /var/tmp
    state: directory
    mode: 01777

# - name: check the RW permission for all 
#   shell: ls -lsrta /var |grep tmp | awk '{ print$2 }'
#   changed_when: False
#   register: rw_permission

# - name: setting the fact 
#   set_fact:  
#     failed_checks:  "{{ failed_checks | string }} the directory /var should have drwxrwxrwt. permission,"
#   when: rw_permission.stdout!="drwxrwxrwt."


- name: umask value checker
  become: yes
  become_user: "{{ oracle_user }}"
  shell: umask
  changed_when: False
  register: umask_value

- name: setting the fact 
  set_fact:  
    failed_checks: "{{ failed_checks | string }} unmask value is neither 22 or 022 or 0022,"
  when: umask_value.stdout | int != 22 or umask_value.stdout | int != 022 or umask_value.stdout | int != 0022

##########################################################
## For all ulimit settings, these could be set with     ##
## `pam_limits` module.  However, like the perms check  ##
## above, it wouldn't just check but instead would set  ##
## the values as needed.                                ##
##                                                      ##
## I believe this one is also work making the change,   ##
## but will leave it for now.  I have provided one      ##
## example, commented out, below                        ##
##                                                      ##
## Also, if we use the `pam_limits` module, the entire  ##
## ulimits section could be written as a loop           ##
##########################################################

# - name: ensure soft files ulimit is 2047
#   pam_limits:
#     domain: "{{ oracle_user }}"
#     limit_type: "soft"
#     limit_item: "nproc"
#     value: "2047"

- name: get ulimit value (soft files)
  become: yes
  become_user: "{{ oracle_user }}"
  shell: ulimit -Sn
  register: ulimit_value

- name: check the ulimit value
  set_fact:
   failed_checks: "{{ failed_checks | string }} ulimit value should be 2047 for ulimit -Sn,"
  when: ulimit_value.stdout | int != 2047

- name: get ulimit value (hard files)
  become: yes
  become_user: "{{ oracle_user }}"
  shell: ulimit -Hn
  register: ulimit_value

- name: check the ulimit value
  set_fact:
   failed_checks: "{{ failed_checks | string }} ulimit value should be 65536 for ulimit -Hn,"
  when: ulimit_value.stdout | int != 65536

- name: get ulimit value (hard procs)
  become: yes
  become_user: "{{ oracle_user }}"
  shell: ulimit -Hu
  register: ulimit_value

- name: check the ulimit value
  set_fact:
   failed_checks: "{{ failed_checks | string }} ulimit value should be 16384 for ulimit -Hu,"
  when: ulimit_value.stdout | int != 16384

- name: get ulimit value (soft stack)
  become: yes
  become_user: "{{ oracle_user }}"
  shell: ulimit -Ss
  register: ulimit_value

- name: check the ulimit value
  set_fact:
   failed_checks: "{{ failed_checks | string }} ulimit value should be 10240 for ulimit -Ss,"
  when: ulimit_value.stdout | int != 10240

- name: get ulimit value (hard stack)
  become: yes
  become_user: "{{ oracle_user }}"
  shell: ulimit -Hs
  register: ulimit_value

- name: check the ulimit value
  set_fact:
   failed_checks: "{{ failed_checks | string }} ulimit value should be unlimited for ulimit -Hs,"
  when: ulimit_value.stdout != "unlimited"

############################################################
## Potentially could use `sysctl` module to set hugepages ##
##                                                        ##
## There are two caveats here:                            ##
## 1. As with otheres, this doesn't just check, but will  ##
##    also change the value if it's not set correctly     ##
## 2. I'm not sure if the setting in the example below    ##
##    is all that's needed.  So there may be more work    ##
##    needed here even if Charter does want to use this   ##
############################################################
# - name: ensure hugepages is set to half the size of memory
#   sysctl:
#     name: vm.nr_hugepages
#     value: "{{ ansible_memtotal_mb * 1024 // 2 }}"
#     state: present

- name: Get The Huge Page Total Size
  shell: grep HugePages /proc/meminfo | awk ' $1 == "HugePages_Total:" {print $2}'
  changed_when: False
  register: huge_page_total_size

- name: Check The Huge Page Total Size
  set_fact:
    failed_checks: "{{ failed_checks | string }} Huge Page size should be half of the RAM size,"
  when: huge_page_total_size.stdout | int < ansible_memtotal_mb * 1024 // 2

- name: Get The Ignored Users In pbis
  slurp:
    src: /etc/pbis/user-ignore
  register: pbis_ignored_users_in_srvr

- name: Check The Ignored Users List In pbis
  set_fact:
    failed_checks: "{{ failed_checks | string }} user ->{{ ignored_user }} is not in pbis ignored user list, "
  when: ignored_user not in pbis_ignored_users_in_srvr.content | b64decode
  loop: "{{ pbis.ignored_users }}"
  loop_control:
    loop_var: ignored_user

- name: Get The Ignored Group In pbis
  slurp:
    src: /etc/pbis/group-ignore
  register: pbis_ignored_group_in_srvr

- name: Check The Ignored Users List In pbis
  set_fact:
    failed_checks: "{{ failed_checks | string }} group --> {{ ignored_group }} is not in pbis ignored group list, "
  when: ignored_group not in pbis_ignored_group_in_srvr.content | b64decode
  loop: "{{ pbis.ignored_groups }}"
  loop_control:
    loop_var: ignored_group

- name: Ensure Local Storage Filesystem is mounted
  set_fact:
    failed_checks: "{{ failed_checks | string }} local filesystem not mounted"
  register: local_fs_check
  when: ansible_mounts | json_query('[?mount == `/u01`]') == []

- name: Check Local Storage Filesystem Size
  set_fact:
    failed_checks: "{{ failed_checks | string }} | size of local filesystem should be greater than 300GB"
  when: 
  - local_fs_check.skipped is defined
  - ansible_mounts | json_query('[?mount == `/u01`].size_total|[0]') | filesizeformat(true) | regex_search('[0-9]*') | int < 300

- debug:
    var: failed_checks

# - name: fail the tasks if the pre-requsites are not satisfied
#   fail: 
#     msg: The following pre-requesties are not met {{ failed_checks | string }}
#   when: failed_checks!=""

## Additional Checks from updated doc
# /dev/shm